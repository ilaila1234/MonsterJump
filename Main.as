package {		import flash.display.MovieClip;	import flash.events.*;	import flash.display.Stage;	import flash.ui.Keyboard;	import com.greensock.TimelineLite;	import com.greensock.TweenLite;	import com.calebtutty.GameContainerMC;			public class Main extends MovieClip {		private var gameContainerMC:MovieClip;				// gameContainer which holds most of the game logic		private var yMouseDistance:Number;					// mouse distance y axis		private var xMouseDistance:Number;					// mouse distance x axis		public var stageReference:Stage = stage;			// stage reference variable, also set by preloader.			public function Main() {			gameContainerMC = new GameContainerMC();		// construct a game container			addChild(gameContainerMC);						// add the game container to the stage			gameContainerMC.x = 738;						// position the gamecontainer			trace("Main constructed");			this.addEventListener( Event.ADDED_TO_STAGE, onAddedToStage );	// on adding to stage call function		}				function onAddedToStage( e:Event ):void {		    trace(onAddedToStage);													stageReference.addEventListener(KeyboardEvent.KEY_DOWN,addKey);		// add keyboard event listeners			stageReference.addEventListener(KeyboardEvent.KEY_UP,removeKey);		// add keyboard event listener				}				public function addKey(event:KeyboardEvent):void {			if (event.keyCode == Keyboard.SHIFT)						// shift is the mousemovementhandler key			{				// If shift, add mouse movement event listener				addEventListener(Event.ENTER_FRAME, handleMouseMovements);			}			else			{				gameContainerMC.playerMC.keysDown[event.keyCode]=true;		// an array is used to bypass the keyboard buffer			}		}				public function removeKey(event:KeyboardEvent):void {			if (event.keyCode == Keyboard.SHIFT)							//if shift is removed			{				gameContainerMC.playerMC.keysDown[Keyboard.UP]=false; // ensure that the keys are turned off				gameContainerMC.playerMC.keysDown[Keyboard.LEFT]=false; 				gameContainerMC.playerMC.keysDown[Keyboard.RIGHT]=false;				removeEventListener(Event.ENTER_FRAME, handleMouseMovements);			}			else			{							gameContainerMC.playerMC.keysDown[event.keyCode]=false;			}		}				public function handleMouseMovements(event:Event):void {						yMouseDistance = stage.mouseY - gameContainerMC.playerMC.y;		// find the distance between the mouse and the player on y axis			xMouseDistance = stage.mouseX - gameContainerMC.playerMC.x;		// find the distance between the mouse and the player on x axis						if (yMouseDistance < -10) {										// ensure at least 10 pixel distance																				// 10 pixels used, so that character doesn't spiral round when the character is right on top of the cursor				gameContainerMC.playerMC.keysDown[Keyboard.UP]=true;			}			else {				gameContainerMC.playerMC.keysDown[Keyboard.UP]=false;			}						if (xMouseDistance < -10) {								gameContainerMC.playerMC.keysDown[Keyboard.LEFT]=true;				gameContainerMC.playerMC.keysDown[Keyboard.RIGHT]=false;			}			else if (xMouseDistance > 10) {				gameContainerMC.playerMC.keysDown[Keyboard.LEFT]=false;				gameContainerMC.playerMC.keysDown[Keyboard.RIGHT]=true;						}			else {				gameContainerMC.playerMC.keysDown[Keyboard.LEFT]=false;				gameContainerMC.playerMC.keysDown[Keyboard.RIGHT]=false;			}		}					}		}