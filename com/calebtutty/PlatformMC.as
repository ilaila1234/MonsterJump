package com.calebtutty {		import flash.display.MovieClip;	import flash.display.Stage;	import flash.text.TextField;	import flash.events.*;	import flash.utils.Timer;	import com.calebtutty.GameVars;	import com.greensock.TimelineLite;	import com.greensock.TweenLite;		import com.calebtutty.SpringMC;	import com.calebtutty.EnemyMC;			public class PlatformMC extends MovieClip {		public var collisionArea:MovieClip;	//this is will hold a reference											//to the playerMC											//so we can test if there is a											//collision													private var _platformType:String;   //this will hold the type of platform,											//as indicated in the XML file.											//Types include:											// - moveSideways											// - oneHitWonder											//		private var idTXT:TextField = new TextField(); // a textfield with the id number for testing purposes.													public var id:int;					//used for testing purposes to identify platform		private var _onScreen:Boolean = true;	// used for destructor clean up purposes												// i.e. if there is additional work to be done												// when taking platform off the stage		private var _aboutToPop:Boolean = false;				private var myTimer:Timer = new Timer(300, 3);			public var movingDirection:String = "right";		private var upDownMovement:int = 0;		public var movingUpDownDirection:String = "up";				private var _specialsMC:MovieClip;				private var _enemyMC:MovieClip;				private var _stageRef:Stage = stage;				public function PlatformMC() {			//trace("PlatformMC constructed");		}						public function collisionTest():Boolean {				if (hitTestObject(collisionArea)) {				if(platformType == "oneHitWonder")				{										if (!_aboutToPop)					{						trace("On the oneHitWonder");						myTimer.addEventListener(TimerEvent.TIMER, disappearPlatform);						myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, popPlatform);						myTimer.start();						_aboutToPop = true;					}														}//				idTXT.text = id.toString();					// for testing purposes, made the platform display ID on//				addChild(idTXT);							// collision. NOTE: Causes odd behaviour due to width of textfield															// and the hittest of what you can land on.				return true;			}			else {				return false;			}		}						public function get platformType():String		{			return _platformType;		}				public function set platformType(value:String):void		{			_platformType = value;						switch(value)			{				case "normal":					gotoAndStop("normal");				break;				case "blue":					gotoAndStop("blue");				break;				case "oneHitWonder":					gotoAndStop("oneHitWonder");				break;				case "moveSideways":					addEventListener(Event.ENTER_FRAME, moveSideways);				break;				case "moveUpandDown":					addEventListener(Event.ENTER_FRAME, moveUpandDown);				break;			}		}				public function get onScreen():Boolean		{			return _onScreen;		}				public function set onScreen(value:Boolean):void		{			_onScreen = value;			if(value == "false")			{				if(_platformType == "moveSideways")				{					removeEventListener(Event.ENTER_FRAME, moveSideways);				}				if(_platformType == "movingUpDown")				{					removeEventListener(Event.ENTER_FRAME, moveUpandDown);				}				if (_platformType == "oneHitWonder")				{					//myTimer.stop()					//myTimer.removeEventListener(TimerEvent.TIMER, popPlatform);				}			}		}				private function moveSideways(e:Event)		{			if(!GameVars.singletonInstance.isPaused)			{							if (e.target.x > 320){					movingDirection = "left";				}				if (e.target.x < 20){					movingDirection = "right";				}							switch(movingDirection)				{					case "right":						e.target.x = e.target.x + 2;					break;					case "left":						e.target.x = e.target.x - 2;					break;				}			}		}				private function moveUpandDown(e:Event)		{						if(!GameVars.singletonInstance.isPaused)			{				if (upDownMovement > 50)				{					movingUpDownDirection = "down";				}				if (upDownMovement < -50)				{					movingUpDownDirection = "up";				}										switch(movingUpDownDirection)				{					case "up":						e.target.y = e.target.y - 2;						upDownMovement++;					break;					case "down":						e.target.y = e.target.y + 2;						upDownMovement--;					break;				}			}		}				private function disappearPlatform(e:TimerEvent)		{			this.alpha = this.alpha - 0.2;		}				private function popPlatform(e:TimerEvent)		{			e.target.stop()			e.target.removeEventListener(TimerEvent.TIMER, disappearPlatform);			e.target.removeEventListener(TimerEvent.TIMER_COMPLETE, popPlatform);			onScreen = false;			trace("Pop it like it's hot ");			this.parent.removeChild(this);		}				public function get specialsMC():MovieClip		{			return _specialsMC;		}				public function createSpecialsMC(value:String)		{			switch (value)			{				case "none":					_specialsMC = null;				break;				case "spring":					_specialsMC = new SpringMC();				break;				case "jetpack":					_specialsMC = new JetpackMC();				break;			}						if(_specialsMC != null)			{				this.addChild(_specialsMC);			}		}				public function addEnemy(hasEnemy:int)		{			switch(hasEnemy)			{				case 0:					_enemyMC = null;				break;				case 1:					_enemyMC = new EnemyMC(1);				break;				case 2:					_enemyMC = new EnemyMC(2);				break;			}						if (_enemyMC != null)			{				addChild(_enemyMC);			}		}				public function get enemyMC():MovieClip		{			return _enemyMC;		}					}		}